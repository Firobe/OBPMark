
std::string kernel_code = 
"void kernel\n"
"process_input_preprocessor(global unsigned int * input_data, global unsigned int *input_data_post_process,global int* zero_block_list_status, global int* zero_block_list,global int* zero_block_list_inverse, int block_size, int number_blocks, unsigned int n_bits, unsigned int x_max, unsigned int offset_input_data_internal, unsigned int offset_input_data_post_process, unsigned int offset_zero_block_list)\n"
"{\n"
"// iter over the numer of blocks\n"
"const unsigned int i = get_global_id(0);\n"
"const unsigned int x_min =  0;\n"
"// update pointers\n"
"input_data += offset_input_data_internal;\n"
"input_data_post_process += offset_input_data_post_process;\n"
"zero_block_list += offset_zero_block_list;\n"
"zero_block_list_status += offset_zero_block_list;\n"
"zero_block_list_inverse += offset_zero_block_list;\n"
"// iterate over the block\n"
"if ( i < number_blocks)\n"
"{\n"
"// first process all data in the blocks this could be maximun to 64 so will perform this opertaion in GPU\n"
"int total_value = 0;\n"
"for ( unsigned int x = 0; x < block_size; ++ x)\n"
"{\n"
"// unit delay input\n"
"unsigned int pre_value = i == 0 && x== 0 ? 0 : input_data[x + (i * block_size) -1];\n"
"const int prediction_error = input_data[x + (i * block_size)] - pre_value;\n"
"const int theta = min((unsigned long)(pre_value - x_min), (unsigned long)(x_max - pre_value));\n"
"int preprocess_sample = theta  + abs(prediction_error);\n"
"// predictor error mapper\n"
"input_data_post_process[x + (i * block_size)] =  0 <= prediction_error && prediction_error <= theta ? 2 * prediction_error :  (-theta <= prediction_error && prediction_error < 0 ? ((2 * abs(prediction_error)) -1): preprocess_sample);\n"
"// Zero block detection\n"
"total_value += input_data_post_process[x + (i * block_size)];\n"
"}\n"
"// update the zero_block_data\n"
"zero_block_list_status[i] =   total_value > 0 ? 0 : 1;\n"
"zero_block_list[i] =  total_value > 0 ? 0 : 1;\n"
"zero_block_list_inverse[i] = total_value > 0 ? 0 : 1;\n"
"}\n"
"}\n"
"void kernel\n"
"process_input_no_preprocessor(global const unsigned int * input_data,global unsigned int *input_data_post_process,global int* zero_block_list_status, global int* zero_block_list,global int* zero_block_list_inverse, int block_size, int number_blocks, unsigned int offset_input_data_internal, unsigned int offset_input_data_post_process, unsigned int offset_zero_block_list)\n"
"{\n"
"// iter over the numer of blocks\n"
"const unsigned int i = get_global_id(0);\n"
"// update pointers\n"
"input_data += offset_input_data_internal;\n"
"input_data_post_process += offset_input_data_post_process;\n"
"zero_block_list += offset_zero_block_list;\n"
"zero_block_list_status += offset_zero_block_list;\n"
"zero_block_list_inverse += offset_zero_block_list;\n"
"if ( i < number_blocks)\n"
"{\n"
"// first process all data in the blocks this could be maximun to 64 so will perform this opertaion in GPU\n"
"int total_value = 0;\n"
"for ( unsigned int x = 0; x < block_size; ++ x)\n"
"{\n"
"// only copy\n"
"input_data_post_process[x + (i * block_size)] = input_data[x + (i * block_size)];\n"
"total_value += input_data[x + (i * block_size)];\n"
"}\n"
"// update the zero_block_data\n"
"zero_block_list_status[i] =   total_value > 0 ? 0 : 1;\n"
"zero_block_list[i] =   total_value > 0 ? 0 : 1;\n"
"zero_block_list_inverse[i] = total_value > 0 ? 0 : 1;\n"
"}\n"
"}\n"
"void kernel\n"
"zero_block_list_completition(global int* zero_block_list,global int* zero_block_list_inverse,global int *missing_value,global int *missing_value_inverse, int stream, int block_size, int number_blocks, unsigned int offset_zero_block_list)\n"
"{\n"
"const unsigned int i = get_global_id(0);\n"
"// update pointers\n"
"zero_block_list += offset_zero_block_list;\n"
"zero_block_list_inverse += offset_zero_block_list;\n"
"if ( i * 2 < number_blocks)\n"
"{\n"
"// first step\n"
"if(i != 0)\n"
"{\n"
"if(zero_block_list[i*2] == 1 && zero_block_list[i*2 + 1] == 1)\n"
"{\n"
"zero_block_list[i*2] = -1;\n"
"zero_block_list[i*2 + 1] = -1;\n"
"atomic_add (&missing_value[stream],2);\n"
"}\n"
"else if(zero_block_list[i*2] == 1)\n"
"{\n"
"zero_block_list[i*2] = -1;\n"
"atomic_add (&missing_value[stream],1);\n"
"}\n"
"// inverse part\n"
"if(zero_block_list_inverse[(number_blocks -1) - (i*2)] == 1 && zero_block_list_inverse[(number_blocks -1) - (i*2 + 1)] == 1)\n"
"{\n"
"zero_block_list_inverse[(number_blocks -1) - (i*2)] = -1;\n"
"zero_block_list_inverse[(number_blocks -1) - (i*2 + 1)] = -1;\n"
"atomic_add (&missing_value_inverse[stream],2);\n"
"}\n"
"else if(zero_block_list_inverse[(number_blocks -1) - (i*2)] == 1)\n"
"{\n"
"zero_block_list_inverse[(number_blocks -1) - (i*2 + 1)] = -1;\n"
"atomic_add (&missing_value_inverse[stream],1);\n"
"}\n"
"}\n"
"else\n"
"{\n"
"if(zero_block_list[0] == 1 && zero_block_list[1] == 1)\n"
"{\n"
"zero_block_list[1] = 2;\n"
"}\n"
"// inverse part\n"
"if(zero_block_list_inverse[(number_blocks -1)] == 1 && zero_block_list_inverse[(number_blocks -1) - 1] == 1)\n"
"{\n"
"zero_block_list_inverse[(number_blocks -1)-1] = 2;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int step = 0;\n"
"while(missing_value[stream] != 0) // TODO:FIXMI JAQUER only works in predetermine case\n"
"{\n"
"if(i != 0)\n"
"{\n"
"if(zero_block_list[(i*2) - (step % 2)] != -1 && zero_block_list[(i*2) + 1 - (step % 2)] == -1)\n"
"{\n"
"zero_block_list[(i*2) + 1 - (step % 2)] = zero_block_list[(i*2) - (step % 2)] + 1;\n"
"atomic_add(&missing_value[stream], -1);\n"
"}\n"
"// inverse part\n"
"if(zero_block_list_inverse[(number_blocks -1) - ((i*2) - (step % 2))] != -1 && zero_block_list_inverse[(number_blocks -1) - ((i*2) + 1 - (step % 2))] == -1)\n"
"{\n"
"zero_block_list_inverse[(number_blocks -1) - ((i*2) + 1 - (step % 2))] = zero_block_list_inverse[(number_blocks -1) - ((i*2) - (step % 2))] + 1;\n"
"atomic_add(&missing_value_inverse[stream], -1);\n"
"}\n"
"}\n"
"step += 1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"adaptative_entropy_encoder_no_compresion(global unsigned int *input_data_post_process,global int *zero_block_list,global unsigned  int *data_in_blocks ,global unsigned int *size_block ,global unsigned char *compresion_identifier,global unsigned char * compresion_identifier_internal,unsigned int id ,int block_size, int number_blocks, int number_bits, unsigned int offset_input_data_post_process, unsigned int offset_zero_block_list, unsigned int offset_data_in_blocks, unsigned int offset_size_block, unsigned int offset_compresion_identifier)\n"
"{\n"
"const unsigned int i = get_global_id(0);\n"
"const unsigned int x = get_global_id(1);\n"
"// update pointers\n"
"input_data_post_process += offset_input_data_post_process;\n"
"zero_block_list += offset_zero_block_list;\n"
"data_in_blocks += offset_data_in_blocks;\n"
"size_block += offset_size_block;\n"
"compresion_identifier += offset_compresion_identifier;\n"
"compresion_identifier_internal += offset_compresion_identifier;\n"
"if ( i < number_blocks && x < block_size)\n"
"{\n"
"if(zero_block_list[i] == 0)\n"
"{\n"
"// no zero block\n"
"// memory position\n"
"const int base_position_data = (id * block_size * number_blocks) + (i * block_size);\n"
"// if is first element in the block do the size and the compresion identifier\n"
"if(x == 0){\n"
"size_block[i + (id * number_blocks)] = number_bits * block_size;\n"
"compresion_identifier_internal[i + (id * number_blocks)] = 32; // NO COMPRESION ID\n"
"// create a ternary tree for selection the compression identifier\n"
"compresion_identifier[i + (id * number_blocks)] = number_bits < 3 ? 0x1 : number_bits < 5 ? 0x3 : number_bits <= 8 ? 0x7 : number_bits <= 16 ? 0xF : 0x1F;\n"
"}\n"
"// copy the data\n"
"//printf(\"i:%d x:%d: %d\\n\",i,x,input_data_post_process[base_position_data + x]);\n"
"data_in_blocks[base_position_data + x] = input_data_post_process[base_position_data + x];\n"
"/*for (unsigned int x = 0; x < block_size ;++x)\n"
"{\n"
"data_in_blocks[base_position_data + x] = input_data_post_process[x + (i * block_size)];\n"
"}*/\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"adaptative_entropy_encoder_zero_block(global unsigned int *input_data_post_process,global int *zero_block_list,global int *zero_block_list_inverse,global unsigned int *data_in_blocks ,global unsigned int *size_block ,global unsigned char *compresion_identifier,global unsigned char *compresion_identifier_internal,unsigned int id ,int block_size, int number_blocks, int number_bits, unsigned int offset_input_data_post_process, unsigned int offset_zero_block_list, unsigned int offset_data_in_blocks, unsigned int offset_size_block, unsigned int offset_compresion_identifier)\n"
"{\n"
"const unsigned int i = get_global_id(0);\n"
"// update pointers\n"
"input_data_post_process += offset_input_data_post_process;\n"
"zero_block_list += offset_zero_block_list;\n"
"zero_block_list_inverse += offset_zero_block_list;\n"
"data_in_blocks += offset_data_in_blocks;\n"
"size_block += offset_size_block;\n"
"compresion_identifier += offset_compresion_identifier;\n"
"compresion_identifier_internal += offset_compresion_identifier;\n"
"if ( i < number_blocks)\n"
"{\n"
"if(zero_block_list[i] != 0)\n"
"{\n"
"// compute ROS\n"
"/*if (zero_block_list[i] < 5)\n"
"{\n"
"size_block[i + (id * number_blocks)] = zero_block_list[i];\n"
"}\n"
"else if(zero_block_list[i] == 5 && zero_block_list_inverse[i] >= 5)\n"
"{\n"
"// ROS\n"
"size_block[i + (id * number_blocks)] = zero_block_list[i];\n"
"}\n"
"else if (zero_block_list[i] >= 5 && zero_block_list_inverse[i] >= 5)\n"
"{\n"
"size_block[i + (id * number_blocks)] = zero_block_list[i] + 1;\n"
"}\n"
"else\n"
"{\n"
"size_block[i + (id * number_blocks)] = zero_block_list[i] + 1;\n"
"}*/\n"
"size_block[i + (id * number_blocks)] = zero_block_list[i];\n"
"compresion_identifier[i + (id * block_size)] = ZERO_BLOCK_ID; // NO COMPRESION ID\n"
"compresion_identifier_internal[i + (id * block_size)] = ZERO_BLOCK_ID;\n"
"const int base_position_data = (id * block_size * number_blocks) + (i * block_size);\n"
"data_in_blocks[(base_position_data)] = 0;\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"adaptative_entropy_encoder_second_extension(global unsigned int *input_data_post_process,global int *zero_block_list,global unsigned int *data_in_blocks ,global unsigned int *size_block ,global unsigned char *compresion_identifier,global unsigned char *compresion_identifier_internal,unsigned int id ,int block_size, int number_blocks, int number_bits, unsigned int offset_input_data_post_process, unsigned int offset_zero_block_list, unsigned int offset_data_in_blocks, unsigned int offset_size_block, unsigned int offset_compresion_identifier)\n"
"{\n"
"const unsigned int i = get_global_id(0);\n"
"// update pointers\n"
"input_data_post_process += offset_input_data_post_process;\n"
"zero_block_list += offset_zero_block_list;\n"
"data_in_blocks += offset_data_in_blocks;\n"
"size_block += offset_size_block;\n"
"compresion_identifier += offset_compresion_identifier;\n"
"compresion_identifier_internal += offset_compresion_identifier;\n"
"unsigned int halved_samples_internal[MAX_NUMBER_OF_BLOCKS];\n"
"if ( i < number_blocks)\n"
"{\n"
"if(zero_block_list[i] == 0)\n"
"{\n"
"const int base_position_data = (id * block_size * number_blocks) + (i * block_size);\n"
"// no zero block so do the second extension\n"
"//identifier\n"
"compresion_identifier[i + (id * number_blocks)] = SECOND_EXTENSION_ID -1; // Second Extension\n"
"compresion_identifier_internal[i + (id * number_blocks)] = SECOND_EXTENSION_ID; // Second Extension\n"
"size_block[i + (id * number_blocks)] = block_size * 32;\n"
"// calculate thing\n"
"for(unsigned int x = 0; x < block_size/2;++x)\n"
"{\n"
"halved_samples_internal[x] = (( (input_data_post_process[((2*x) + (i * block_size))] + input_data_post_process[((2*x) + (i * block_size)) + 1]) * (input_data_post_process[((2*x) + (i * block_size))] + input_data_post_process[((2*x) + (i * block_size)) + 1] + 1)) / 2) + input_data_post_process[((2*x) + (i * block_size)) + 1];\n"
"}\n"
"// get size\n"
"unsigned int size = 0;\n"
"// get size\n"
"for(int x = 0; x <  block_size/2; ++x)\n"
"{\n"
"size += halved_samples_internal[x] + 1;\n"
"// store output\n"
"}\n"
"// store size\n"
"if(size < (block_size * 32))\n"
"{\n"
"size_block[i + (id * number_blocks)] = size;\n"
"for(int x = 0; x <  block_size/2; ++x)\n"
"{\n"
"// store output\n"
"data_in_blocks[base_position_data + x] = halved_samples_internal[x];\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"adaptative_entropy_encoder_sample_spliting(global unsigned  int *input_data_post_process,global int *zero_block_list,global unsigned  int *data_in_blocks ,global unsigned int *size_block ,global unsigned char *compresion_identifier,global unsigned char *compresion_identifier_internal,unsigned int id ,int block_size, int number_blocks, int number_bits, unsigned int offset_input_data_post_process, unsigned int offset_zero_block_list, unsigned int offset_data_in_blocks, unsigned int offset_size_block, unsigned int offset_compresion_identifier)\n"
"{\n"
"const unsigned int i = get_global_id(0);\n"
"// update pointers\n"
"input_data_post_process += offset_input_data_post_process;\n"
"zero_block_list += offset_zero_block_list;\n"
"data_in_blocks += offset_data_in_blocks;\n"
"size_block += offset_size_block;\n"
"compresion_identifier += offset_compresion_identifier;\n"
"compresion_identifier_internal += offset_compresion_identifier;\n"
"if ( i < number_blocks)\n"
"{\n"
"if(zero_block_list[i] == 0)\n"
"{\n"
"// no zero block so do the sample spliting\n"
"const int base_position_data = (id * block_size * number_blocks) + (i * block_size);\n"
"const unsigned int k = (id - 2);\n"
"compresion_identifier[i + (id * number_blocks)] = SAMPLE_SPLITTING_ID + k  - 2; // SAMPLE_SPLITTING_ID\n"
"compresion_identifier_internal[i + (id * number_blocks)] = SAMPLE_SPLITTING_ID + k ; // SAMPLE_SPLITTING_ID\n"
"if(k >= number_bits -2)\n"
"{\n"
"size_block[i + (id * number_blocks)] = block_size * 32;\n"
"}\n"
"else if (k == 0)\n"
"{\n"
"// get fundamental sequence\n"
"compresion_identifier[i + (id * number_blocks)] = 1; // FUNDAMENTAL_SEQUENCE_ID\n"
"compresion_identifier_internal[i + (id * number_blocks)] = 1; // FUNDAMENTAL_SEQUENCE_ID\n"
"// first get size and process the output at the same time\n"
"unsigned int size = 0;\n"
"for(int x = 0; x < block_size; ++x)\n"
"{\n"
"// get the size\n"
"size += input_data_post_process[(x + (i * block_size))] + 1;\n"
"}\n"
"size_block[i + (id * number_blocks)] = size;\n"
"if(size < block_size * 32)\n"
"{\n"
"for(int x = 0; x < block_size; ++x)\n"
"{\n"
"// create output\n"
"data_in_blocks[base_position_data + x]  = input_data_post_process[(x + (i * block_size))];\n"
"}\n"
"}\n"
"}\n"
"else\n"
"{\n"
"// sample spliting when k != 0 and k >= n_bits -3\n"
"unsigned int size = 0;\n"
"for(int x = 0; x < block_size; ++x)\n"
"{\n"
"// get the size\n"
"size += (k + (input_data_post_process[(x + (i * block_size))] >> k)) + 1;\n"
"data_in_blocks[base_position_data + x]  = input_data_post_process[(x + (i * block_size))];\n"
"}\n"
"size_block[i + (id * number_blocks)] = size;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"adaptative_entropy_encoder_block_selector(global int *zero_block_list ,global unsigned int *bit_block_best,global unsigned int *size_block ,global unsigned char *compresion_identifier,global unsigned char *compresion_identifier_internal ,global unsigned int *size_block_best ,global unsigned char *compresion_identifier_best,global unsigned char *compresion_identifier_internal_best,int block_size, int number_blocks, int number_bits, unsigned int offset_zero_block_list, unsigned int offset_bit_block_best, unsigned int offset_size_block, unsigned int offset_compresion_identifier , unsigned int offset_size_block_best, unsigned int offset_compresion_identifier_best)\n"
"{\n"
"// select the best only one can survive\n"
"const unsigned int i = get_global_id(0);\n"
"// update pointers\n"
"zero_block_list += offset_zero_block_list;\n"
"bit_block_best += offset_bit_block_best;\n"
"size_block += offset_size_block;\n"
"compresion_identifier += offset_compresion_identifier;\n"
"compresion_identifier_internal += offset_compresion_identifier;\n"
"size_block_best += offset_size_block_best;\n"
"compresion_identifier_best += offset_compresion_identifier_best;\n"
"compresion_identifier_internal_best += offset_compresion_identifier_best;\n"
"if ( i < number_blocks)\n"
"{\n"
"unsigned int best_id = 0;\n"
"if(zero_block_list[i] == 0)\n"
"{\n"
"// is not zero block\n"
"unsigned int size_minmun = 999999;\n"
"for(unsigned int method = 0; method < number_bits + 2; ++ method)\n"
"{\n"
"if (size_block[i + (method * number_blocks)] < size_minmun)\n"
"{\n"
"size_minmun = size_block[i + (method * number_blocks)];\n"
"best_id = method;\n"
"}\n"
"}\n"
"// best ID geted Now process\n"
"//const int base_position_data = (best_id * block_size * number_blocks) + (i * block_size);\n"
"bit_block_best[i] = best_id;\n"
"size_block_best[i] = size_block[i + (best_id * number_blocks)];\n"
"compresion_identifier_best[i] = compresion_identifier[i + (best_id * number_blocks)];\n"
"compresion_identifier_internal_best[i] = compresion_identifier_internal[i + (best_id * number_blocks)];\n"
"// copy data\n"
"}\n"
"else\n"
"{\n"
"// is 0 block\n"
"//const int base_position_data = (best_id * block_size * number_blocks) + (i * block_size);\n"
"size_block_best[i] = size_block[i + (best_id * number_blocks)];\n"
"compresion_identifier_best[i] =   ZERO_BLOCK_ID;\n"
"compresion_identifier_internal_best[i] = ZERO_BLOCK_ID;\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"adaptative_entropy_encoder_block_selector_data_copy(global int *zero_block_list,global unsigned  int *data_in_blocks ,global unsigned int *bit_block_best,global unsigned  int *data_in_blocks_best ,int block_size, int number_blocks, unsigned int offset_zero_block_list, unsigned int offset_data_in_blocks, unsigned int offset_bit_block_best, unsigned int offset_data_in_blocks_best)\n"
"{\n"
"const unsigned int i = get_global_id(0);\n"
"const unsigned int x = get_global_id(1);\n"
"// update pointers\n"
"zero_block_list += offset_zero_block_list;\n"
"data_in_blocks += offset_data_in_blocks;\n"
"bit_block_best += offset_bit_block_best;\n"
"data_in_blocks_best += offset_data_in_blocks_best;\n"
"if ( i < number_blocks && x < block_size)\n"
"{\n"
"if(zero_block_list[i] == 0)\n"
"{\n"
"const int base_position_data = (bit_block_best[i] * block_size * number_blocks) + (i * block_size);\n"
"data_in_blocks_best[(i* block_size) + x] = data_in_blocks[base_position_data + x];\n"
"}\n"
"else\n"
"{\n"
"data_in_blocks_best[(i* block_size)] = 1;\n"
"}\n"
"}\n"
"}\n"
;
