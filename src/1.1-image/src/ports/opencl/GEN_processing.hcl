
std::string kernel_code = 
"// NOTE: in opencl the implementation of the uint16/uint32 ar not fully working and we need to use the c like types\n"
"// so uint16_t will be switch to unsigned short\n"
"// and uint32_t  will be switch to unsigned int\n"
"// and uint8_t will be switch to unsigned char\n"
"// TODO move to a top level\n"
"#define uint32_t_cl unsigned int\n"
"#define uint16_t_cl unsigned short\n"
"#define uint8_t_cl unsigned char\n"
"void kernel\n"
"f_offset(\n"
"global uint16_t_cl *frame,\n"
"const int i,\n"
"global const uint16_t_cl *offsets,\n"
"const int size\n"
")\n"
"{\n"
"global uint16_t_cl *frame_i;\n"
"frame_i = frame + (size * i);\n"
"uint32_t_cl x = get_global_id(0);\n"
"if (x < size)\n"
"{\n"
"frame_i[x] = frame_i[x] - offsets[x];\n"
"}\n"
"}\n"
"void kernel\n"
"f_mask_replace(\n"
"global uint16_t_cl *frame,\n"
"const int i,\n"
"global const uint8_t_cl *mask,\n"
"const uint32_t_cl width,\n"
"const uint32_t_cl height\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"const int kernel_rad = 1;\n"
"uint32_t_cl n_sum = 0;\n"
"uint32_t_cl sum = 0;\n"
"global uint16_t_cl *frame_i;\n"
"frame_i = frame + (width * height  * i);\n"
"if (x < width && y < height)\n"
"{\n"
"if (mask[y* width + x] == 1)\n"
"{\n"
"for(int i = -kernel_rad; i <= kernel_rad; ++i) // loop over kernel_rad  -1 to 1 in kernel_size 3\n"
"{\n"
"for(int j = -kernel_rad; j <= kernel_rad; ++j){\n"
"if (!((i + x < 0 || j + y < 0) || ( i + x > height - 1 || j + y > width - 1)))\n"
"{\n"
"//printf(\"POS s x %d y %d value %d\\n\", y + j, x + i, (y + j)* width + (x + i));\n"
"if ( mask[(y + j)* width + (x + i)] == 0)\n"
"{\n"
"sum = sum + (uint32_t_cl)(frame_i[(y + j)*width+(x + i)]);\n"
"++n_sum;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"//if (y == 541 && x == 140){printf(\"POS s x %d y %d value %u:%u\\n\",y, x, sum, n_sum);}\n"
"if (n_sum == 0)\n"
"{\n"
"frame_i[y * width + x] = 0;\n"
"}\n"
"else{\n"
"frame_i[y * width + x] = (uint16_t_cl)((unsigned int)(sum / n_sum));\n"
"}\n"
"//frame_i[y * width + x] = (uint16_t_cl)(n_sum == 0 ? 0 : (uint32_t_cl)(sum) / (uint32_t_cl)(n_sum));\n"
"}\n"
"//printf(\"POS s x %d y %d value %d\\n\", threadIdx.x, threadIdx.y, frame[y * width + x]);\n"
"}\n"
"}\n"
"void kernel\n"
"f_scrub(\n"
"global uint16_t_cl *frame,\n"
"const uint32_t_cl frame_i,\n"
"const uint8_t_cl frame_i_0,\n"
"const uint8_t_cl frame_i_1,\n"
"const uint8_t_cl frame_i_2,\n"
"const uint8_t_cl frame_i_3,\n"
"const uint32_t_cl width,\n"
"const uint32_t_cl height\n"
")\n"
"{\n"
"const uint32_t_cl num_neighbour = 4;\n"
"uint32_t_cl sum;\n"
"uint32_t_cl mean;\n"
"uint32_t_cl thr;\n"
"global uint16_t_cl *frame_0;\n"
"global uint16_t_cl *frame_1;\n"
"global uint16_t_cl *frame_2;\n"
"global uint16_t_cl *frame_3;\n"
"global uint16_t_cl *frame_i_point;\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < width && y < height)\n"
"{\n"
"/* Init Frames position */\n"
"frame_0 = frame + ((height * width) * frame_i_0);\n"
"frame_1 = frame + ((height * width) * frame_i_1);\n"
"frame_2 = frame + ((height * width) * frame_i_2);\n"
"frame_3 = frame + ((height * width) * frame_i_3);\n"
"frame_i_point = frame + ((height * width) * frame_i);\n"
"sum = (uint32_t_cl)(frame_0[y * width + x] + frame_1[y * width + x] + frame_2[y * width + x] + frame_3[y * width + x]);\n"
"/* Calculate mean and threshold */\n"
"mean = (uint32_t_cl)( sum / num_neighbour);\n"
"thr = 2  * mean;\n"
"/* If above threshold, replace with mean of temporal neighbours */\n"
"//if (y == 541 && x == 140){printf(\"%u POS s x %d y %d value %u:%u ---- %u %u %u %u\\n\", frame_i_3, y, x, thr, mean, frame_0[y * width + x],frame_1[y * width + x],frame_2[y * width + x],frame_3[y * width + x]);}\n"
"if (frame_i_point[y * width + x] > thr)\n"
"{\n"
"//printf(\"POS s x %d y %d value %u:%u\\n\", y, x, thr, mean);\n"
"frame_i_point[y * width + x] = (uint16_t_cl)mean;\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"f_gain(\n"
"global uint16_t_cl *frame,\n"
"const uint32_t_cl i,\n"
"global uint16_t_cl *gains,\n"
"const uint32_t_cl size,\n"
"const uint32_t_cl width,\n"
"const uint32_t_cl height\n"
")\n"
"{\n"
"global uint16_t_cl *frame_i;\n"
"int x = get_global_id(0);\n"
"frame_i = frame + ((height * width) * i);\n"
"if (x < size)\n"
"{\n"
"frame_i[x] = (uint16_t_cl)((uint32_t_cl)frame_i[x] * (uint32_t_cl)gains[x] >> 16 );\n"
"}\n"
"}\n"
"void kernel\n"
"f_2x2_bin_coadd(\n"
"global uint16_t_cl *frame,\n"
"const uint32_t_cl i_frame,\n"
"global uint32_t_cl *sum_frame,\n"
"const uint32_t_cl width,\n"
"const uint32_t_cl height,\n"
"const uint32_t_cl lateral_stride\n"
")\n"
"{\n"
"const uint32_t_cl stride = 2;\n"
"uint32_t_cl sum = 0;\n"
"global uint16_t_cl *frame_i;\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"frame_i = frame + (height * 2 * width * 2 * i_frame);\n"
"if (i < width && j < height){\n"
"#pragma unroll\n"
"for(uint32_t_cl x = 0; x < stride; ++x)\n"
"{\n"
"#pragma unroll\n"
"for(uint32_t_cl y = 0; y < stride; ++y)\n"
"{\n"
"sum +=  (uint16_t_cl)frame_i[((j * stride) + x) * (width * stride) + ((i*stride) +y)];\n"
"}\n"
"}\n"
"sum_frame[j * lateral_stride + i ]= sum + sum_frame[j * lateral_stride + i ];\n"
"}\n"
"}\n"
;
