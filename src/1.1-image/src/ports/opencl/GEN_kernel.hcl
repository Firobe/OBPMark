
std::string kernel_code = 
"void kernel\n"
"f_offset(\n"
"global uint16_t *frame,\n"
"global const uint16_t offsets,\n"
"const int size\n"
")\n"
"{\n"
"unsigned int x = get_global_id(0);\n"
"if (x < size)\n"
"{\n"
"frame[x] = frame[x] - offsets[x];\n"
"}\n"
"}\n"
"void kernel\n"
"f_mask_replace(\n"
"global uint16_t *frame,\n"
"global const uint16_t *mask,\n"
"const unsigned int width,\n"
"const unsigned int height\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"const int kernel_rad = 1;\n"
"unsigned int n_sum = 0;\n"
"uint32_t sum = 0;\n"
"if (x < width && y < height)\n"
"{\n"
"if (mask[y* width + x] != 0)\n"
"{\n"
"for(int i = -kernel_rad; i <= kernel_rad; ++i) // loop over kernel_rad  -1 to 1 in kernel_size 3\n"
"{\n"
"for(int j = -kernel_rad; j <= kernel_rad; ++j){\n"
"if (!(i + x < 0 || j + y < 0) || !( i + x > height - 1 || j + y > width - 1))\n"
"{\n"
"if ( mask[(y + j)* width + (x + i)] == 0)\n"
"{\n"
"sum += frame[(x + i)*width+(y + j)];\n"
"++n_sum;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"frame[y * width + x] = (uint16_t)(n_sum == 0 ? 0 : sum / n_sum);\n"
"}\n"
"//printf(\"POS s x %d y %d value %d\\n\", threadIdx.x, threadIdx.y, frame[y * width + x]);\n"
"}\n"
"}\n"
"void kernel\n"
"f_scrub(\n"
"global uint16_t *frame,\n"
"global uint16_t *frame_i_0,\n"
"global uint16_t *frame_i_1,\n"
"global uint16_t *frame_i_2,\n"
"global uint16_t *frame_i_3,\n"
"const unsigned int width,\n"
"const unsigned int height\n"
")\n"
"{\n"
"static unsigned int num_neighbour = 4;\n"
"uint32_t sum;\n"
"uint32_t mean;\n"
"uint32_t thr;\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < width && y < height)\n"
"{\n"
"sum = frame_i_0[y * width + x] + frame_i_1[y * width + x] + frame_i_2[y * width + x] + frame_i_3[y * width + x];\n"
"/* Calculate mean and threshold */\n"
"mean = sum / (num_neighbour);\n"
"thr = 2*mean;\n"
"/* If above threshold, replace with mean of temporal neighbours */\n"
"if (frame[y * width + x] > thr)\n"
"{\n"
"frame[y * width + x] = (uint16_t)mean;\n"
"}\n"
"}\n"
"}\n"
"void kernel\n"
"f_gain(\n"
"global uint16_t *frame,\n"
"global uint16_t *gains,\n"
"const unsigned int size\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"if (x < size)\n"
"{\n"
"frame[x] = (uint16_t)((uint32_t)frame[x] * (uint32_t)gains[x] >> 16 );\n"
"}\n"
"}\n"
"void kernel\n"
"f_2x2_bin_coadd(\n"
"global uint16_t *frame,\n"
"global uint32_t *sum_frame,\n"
"const unsigned int width,\n"
"const unsigned int height,\n"
"const unsigned int lateral_stride\n"
")\n"
"{\n"
"const unsigned int stride = 2;\n"
"uint32_t sum = 0;\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < width && j < height){\n"
"#pragma unroll\n"
"for(unsigned int x = 0; x < stride; ++x)\n"
"{\n"
"#pragma unroll\n"
"for(unsigned int y = 0; y < stride; ++y)\n"
"{\n"
"sum +=  frame[((j * stride) + x) * width + ((i*stride) +y)];\n"
"}\n"
"}\n"
"sum_frame[j * lateral_stride + i ]= sum + sum_frame[j * lateral_stride + i ];\n"
"}\n"
"}\n"
;
